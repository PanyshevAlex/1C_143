# 1C_143
## Алгоритм решения
Получаем изображение в виде массива пикселей. Далее определяем границы игрового поля: проходим по пикселю сверху и ищем черный пиксель, это будет самый верхний пиксель, принадлежащий нашему полю, то есть его верхняя граница. Аналогично ищем нижнюю, левую и правую границы. Далее, учитывая что секторы одинакового размера, определяем координаты каждого сектора. Узнав координаты каждого сектора можем определить что находится в них. Так как крестики и нолики у нас центрированы то если в секторе крестик то в самом центре должен быть черный пиксель (в случае нолика или отсутствия чего либо там пусто), тогда первым делом смотрим в центр если есть черный пиксель, то там крестим, запоминаем это и переходим к следующему сектору. Если крестика не оказалось, то остается нолик или ничего. Пройдем с левой границы сектора в правую по фиксированному y (центр сектора по y). Если мы встретим 3 или 4 раза черные линии, то там нолик: два раза встретили нолик и один/два раза границу. Если встретили черные линии меньше раз (1 или 2), то там ничего нет, запомнили. Теперь мы знаем как у нас расположены крестики и нолики в поле. Осталось определить является ли текущее состояние победным и если да то для кого, а также какие секторы образуют победную "тройку". Определяем это просто перебрав все горизонтальные, вертикальные и диагональные тройки. После этого в случае отсутствия победы печатаем это, в случае победы рисуем линию (зная номера секторов определяем координаты начала и конца линии)
## Некоторые мысли по решению
В приведенном решении я решил не отсекать границы, когда определял положение секторов, что оказало некоторое влияние на код (при определении нолика смотрим на количество линии с учетом того, что там присутсвует одна или две границы). По идее это может повлечь некоторые проблемы если у нас границы поля нарисованы в один два пикселя, но я посчитал такую ситуацию как минимум странной (ведь у нас сказано, что все одной толщины) и решил, что такую ситуацию мы не будем рассматривать. Но в целом мы легко могли после имеющегося определения координат секторов дополнительно отсечь и границы для каждого сектора, но это понесло бы некоторые затраты по времени работы, что не очень хорошо. Поэтому опишу алгоритм здесь: можно было просто пройти по одной координаты от одного из концов сектора, при фиксированной другой координате(соответсвующей центральной линии сектора), пока не дойдем до прозрачной. И просто обновить соответствующую координату сектора, причем, учесть это для всех секторов прилегающих к рассматриваемой границы. Тогда на имеющийся код это повлияло бы следующим образом: при определении нолика мы бы ожидали не 4 или 3 черных линии, а ровно две, и ноль для пустого сектора. Это можно очень просто реализовать, но опять же я решил, что это не требуется.